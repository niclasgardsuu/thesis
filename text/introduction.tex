
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

The most common technique for automatic memory management is garbage collection. The task of a garbage collector is to keep track of which parts of memory are being used by the program which is being executed. Different implementations of garbage collectors offer different benefits over others. The choice of garbage collector heavily impacts the performance and characteristics of the program being executed.

Java is a programming language with dynamic memory management that makes use of garbage collectors to handle memory. Operating within a runtime environment known as the Java Virtual Machine (JVM), Java allows users to configure the JVM to improve performance, including the choice of garbage collector. This thesis explores possible improvements that can be made to the JVM and its garbage collectors. Specifically, the goal is to look at the possibility of implementing a new method for compacting memory in ZGC, one of Java's most recently added garbage collectors.

ZGC stores data in different regions of memory, where every region includes a set of objects that have been allocated by the Java program running. These regions of memory are referred to as pages. During the compaction phase of a garbage collector, the goal is to decrease the amount of fragmented memory in these pages. A common issue with garbage collectors is the presence of fragmented memory. Fragmented memory can occur when previously allocated objects are suddenly not needed by the program. These dead objects then create holes of unused memory that lie between other live objects still used by the Java program. 

In ZGC, a so-called \textit{bump pointer} is used for allocating objects, which offers a fast method of allocating objects, but limits the choice of where to place the objects. To reclaim the unreachable memory, ZGC performs compaction on a page by evacuating all of its live objects into a new empty region, placing them more compactly to get rid of the holes in memory. And if there is no available memory to create an empty page, a more computationally heavy operation will be done to compact all objects into the same page they are currently in. Creating new pages and doing computationally heavy operations to perform compaction are the only two options for ZGC, but with the new method that is explored in this thesis, it is possible to relocate objects straight into the fragmented holes of memory using a free-list based allocator. The benefit of representing memory with free-lists is that it does not limit the available memory to a singular contiguous block of memory like the bump-pointer, instead allowing free memory to be represented by a set of many smaller blocks of memory.

During this thesis, two different free-list based allocators were integrated into ZGC. Both allocators offer the same functionality, but differ in their performance due to their different design choices. J. Sikström and C. Norrbin have both conducted separate thesises on the implementation of a TLSF allocator~\cite{joel} and a Buddy allocator~\cite{casper}, respectively. These allocators were designed by Sikström and Norrbin to meet the requirements of ZGC, and this thesis shows their integration into ZGC to be used for compacting memory. 