
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

\subsection{Integration Method}
% https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6312870 källa kanske. 1975 LOL

This thesis employs a cyclical development method for integrating a new feature into an existing codebase. The approach is designed to iteratively refine the integration through repeated iterations of evaluation and modification.

\begin{description}
  \item[Phase 1: Analysis]
  The initial phase involves a detailed examination of the system to identify areas impacted by the integration of the new feature. This involves an in-depth review of the existing code, experimental adjustments to observe possible impacts, and consultations with the code's original developers. The purpose of this phase is to gain a comprehensive understanding of the system's functionality and dependencies, which facilitates accurate identification of critical modification points.
  
  \item[Phase 2: Iterative Integration]
  Following the preliminary analysis, the integration ph-ase proceeds in an iterative manner. It begins with creating an implementation design, derived from the insights gained during the analysis phase. The integration then proceeds with applying the planned changes, followed by testing to evaluate the correctness and impact of these changes. If the integration achieves the expected outcomes, the process is completed. If not, the feedback from testing informs further refinements in the plan, and the cycle repeats - designing, implementing, and testing — until the integration fully aligns with the desired functionality, and programs are executed without errors.
\end{description}

This cyclical method offers a systematic approach to implementing new functions in a large code base. By iteratively improving the design, and always making sure to assess the current iterations impacts on the code before moving on to further changes, the final implementation is less prone to fail.

% This project outlines the integration of a new feature in a large code base. New implementations in large code bases tend to have bigger impacts than intended since it is hard to know which parts of the system are going to be impacted. The integration method used during this thesis consists of two different phases, the identification phase, and then the implementation phase. 

% The goal of the first identification phase is to study the behavior of the program in the areas that are going to be impacted. This involves reading the code, changing the code to see the impacts, and also talking to the authors of the code to better understand what implications a small change might have. The goal is that by the end of this phase, enough information will be gathered about the different parts of the system such that it would be easier to identify which parts of the code have to be changed to implement the new feature.

% The second phase involves the process of actually implementing the desired changes. Firstly, a design of the implementation is made from the gathered knowledge of the identification phase. Following this, an iterative method of implementing the design and testing it is done. If the implementation works as intended, the implementation is considered done, and if the implementation does not work as intended, the implementation phase is restarted and a new design has to be made from the knowledge gathered from the failed tests.

\subsection{Exploratory Programming}
The main method for implementing new changes to the JVM code was using exploratory programming. This method implies making changes to the code and seeing what impacts the changes have based on data that is collected from the program. Some tools used to facilitate this process were debuggers and logging tools. In this section, I explain two useful tools that simplify the process of understanding the code.

\subsubsection{Debuggers}
A debugger is a tool that can run your program with an interface to let the developer know the values of certain variables or locations of memory addresses. A useful tool used during this project is the \textit{rr\_debugger}, designed by O'Callahan et al.~\cite{rrdebugger}, which can be used to record and replay a program's execution with deterministic behavior. This makes it possible to view parts of the program at different times. This is very useful in the context of the OpenJDK since the code consists of several hundreds of thousands of lines of code, which makes it easy to have different parts of the system interacting with each other without the developer knowing. Finding which areas in the code are causing the problem is very important for successfully debugging a faulty program, and this is what the debugger is used for.

\subsubsection{Logging}
The Open JDK has access to logging tools that can produce output files with information about the JVM during its runtime~\cite{java:logs}. This is a powerful tool when working with a large code base because it allows for user-friendly interpretation of the execution of code inside the JVM. While debuggers are useful for understanding the code's execution, the logs provide a more summarized explanation of how the code was executed. 

The JVM is already equipped with different types of log outputs, such as logs that display the performance of the garbage collector. By implementing a new allocation strategy, the JVM can be further equipped with useful information about the performance of the free-list allocator. This is used during this thesis to gather valuable insights into the performance of the new allocators.